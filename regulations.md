# Секция 2.6. Проект по разработке компьютерной игры
1. Начиная с темы Оконные приложения студенты разрабатывают компьютерную игру до конца семестра параллельно с остальными темами. 
2. Игра разрабатывается индивидуально. 
3. За игру студент в течение семестра может получить до 600 баллов, которые выставляются в ulearn. 600 баллов соответствуют 15 итоговым баллам за семестр. Шкала преобразования линейная. 
4. Также по желанию студента игра получившая больше 400 баллов в ulearn может быть выставлена на конкурс. В конкурсе студенты могут получить до 10 итоговых баллов за семестр.


## Промежуточные встречи с преподавателем
1. Начиная с темы оконные приложения и до конца семестра, каждую неделю студент может обсудить с преподавателем свой прогресс в разработке игры на компьютерных практиках. Промежуточные встречи дают максимально до 200 баллов за демонстрацию прогресса по работе.
2. Всего будет несколько промежуточных встреч (минимально 2) у студентов с преподавателем на тему разработки игры. Их количество и график для каждого студента планирует и озвучивает преподаватель на теме оконные приложения. Встречи проходят во время прохождения тем с «Графы и обходы» по «Динамическое программирование». На каждой встрече студент может получить определенное количество баллов (равномерно пропорционально разделенное количеству промежуточных встреч) из 200 (на усмотрение преподавателя) за равномерность прогресса. Оценки по результатам встречи выставляются в ulearn.me.
3. Студент сам планирует, какой результат он сможет продемонстрировать преподавателю к следующей промежуточной встрече и озвучивает свои планы преподавателю. Преподаватель высказывает свое мнение и дает рекомендации по улучшению результатов и по планированию прогресса. Все решения по игре принимает студент.
4. Баллы могут быть снижены, если студент не демонстрирует на промежуточных встречах никакого прогресса по работе и/или не следует советам преподавателя.
5. Студент должен завести репозиторий на github.com и использовать git для работы над кодом. Репозиторий может быть публичным или приватным. К приватному репозитории следует дать доступ преподавателю.
6. Во время встречи с преподавателем прогресс планов и результатов фиксируется в github. 


## Финальная встреча
1. Во время темы «Структуры данных» состоится финальная встреча по игре. На ней преподаватель оценивает уже не процесс, а итоговый результат. Финальная встреча дает 400 баллов за результат.

| Критерий | Количество баллов |
| -------- | ----------------- |
| Архитектура кода| 100 |
| Соответствие принципам программирования | 100 |
| Сложность и оригинальность игровых механик | 65 |
| Техническая проработанность проекта | 65 |
| Играбельность | 70 |
| Конкурс игр | 10 (Бонусные баллы) |


## Архитектура кода
Корректная, обоснованная реализация архитектуры проекта.
1. Код написан с применением паттерна MVC (либо другого подходящего паттерна для проектирования игры). В коде студента четко прослеживаются три ветви проектирования: модель, отображение, контроллер. Классы модели изолированы от фреймворка, на котором разрабатывается игра и могут быть безболезненно извлечены из проекта без переписывания кода игры. Модель не должна содержать в себе специфического кода фреймворка. Классы отображения получают данные от модели по её инициативе, а не используют проверку через запросы или паттерн «Игровой цикл». Классы контроллера взаимодействуют только с моделью и не имеют ссылок на классы отображения.
2. Все файлы классов модели, контроллера и представления разложены по соответствующим папкам и подпапкам. Файлы разделены на три папки: “Model” “View” “Controller” в случае применения паттерна MVC. В случае применения студентом других паттернов проектирования он в праве изменять названия папок, оставляя их интуитивно понятными и соотносящимися по смыслу с тематикой файлов, находящихся в папке. Код разложен по папкам таким образом, чтобы все файлы, по смыслу затрагивающие сущность, лежали вместе с файлом сущности. Под каждый class, interface или enum создан отдельный файл. Запрещено создавать папки по типу сущностей в нем, таким образом папки Classes, Interfaces, Enums, Structs являются примером неправильно построенной иерархии. Файлы Enum находятся в той же папке, что и файл основной сущности, для которой они предназначены. Файлы Interfaces находятся в папке, в которой находятся файлы классов, реализующих этот интерфейс. Для удобства организации хранения допускается создание подпапок в директориях, предназначенных для хранения классов, реализующих интерфейс и классов-наследников.
3. Отсутствуют прямые вызовы методов отрисовки в контроллере и модели. Классы отрисовки отслеживают изменения модели и вызываю методы для изменения демонстрируемых на экране значений и свойств только после изменения значения модели. Классы отрисовки не проверяют, изменилось ли значение поля класса модели.
4. Используется паттерн "Наблюдатель" (Observer) для отрисовки значений в пользовательском интерфейсе. Для сообщения классам отрисовки о необходимости изменения демонстрируемого значения в связи с изменением значения поля класса модели используется паттерн наблюдатель. Его следует реализовывать не посредствам фреймворка, а средствами языка.


## Соответствие принципам программирования
Соответствие разобранным на курсе принципам программирования: SOLID, DRY, KISS, "целостность данных" и другим.

1. Правильная декомпозиция всего проекта по классам. Классы в коде имеют ясную функциональность, которая обозначена в названии класса. Функциональность, выполняемая классом, охватывает узкую часть программы. В классах нет кода, который не используется или устарел. Классы не реализуют несколько функций одновременно, если задачу класса можно декомпозировать на два или более классов – класс считается объемным, использование таких классов – нежелательно. 
2. Отсутствие дублирования кода. В коде нет абсолютно идентичных частей или частей отличающихся только названиями входных параметров или их типом. Если дублирующийся код в классах можно изолировать и вынести в метод – такой код считается нежелательным, его следует переработать, обеспечив к нему доступ из классов, в которых находится нежелательный код.
3. Корректное использование принципов ООП: наследование, полиморфизм, инкапсуляция. В коде прослеживается парадигма ООП. Применяется наследование, классы студента имеют виртуальные или абстрактные поля или методы, которые переопределяются в классах-наследниках. Для избежания дублирования кода применяются абстрактные классы или дефолтные реализации методов интерфейса, добавленные в C# 11, если это представляется возможным. В классах есть приватные методы и поля, изолированные от внешних классов. В классах созданы удобные и понятные публичные методы взаимодействия с ними для работы с экземплярами классов или статическими классами. Все названия методов, классов, интерфейсов, перечислений, переменных, полей, свойств и других сущностей пишутся словами английского языка и отражают суть сущности, которой они присвоены. Наименование сущности транскриптом или словами не английского языка являются нежелательными, такие наименования необходимо изменить.
4. Для взаимодействия со своими классами студент создал публичные методы, названия которых понятны, говорят сами за себя. У классов студента нет публичных методов, вызов которых нарушает работоспособность остального когда. В классах отсутствуют сложные сеттеры и геттеры свойств, которые приводят к не интуитивному поведению программы и выводят из строя игру. Отсутствуют методы, вызов которых при определенных условиях или с определенными параметрами приведет к нежелательному поведению программы, выводу из строя устройства пользователя или некорректной работе приложения. 


## Сложность и оригинальность игровых механик
1. В коде игры присутствуют сложные алгоритмы, определяющие ход игрового процесса или играющие значительную роль в функциональности игровых механик. Высокую сложность и оригинальность механик определяет использование в коде игры уникальных алгоритмов. Уникальный алгоритм - собственноручно написанный студентом алгоритм под специфические задачи его приложения считается уникальным. Если алгоритм, ход работы которого полностью совпадает с ходом работы алгоритма студента, уже был написан ранее – алгоритм студента по-прежнему считается уникальным, если весь код алгоритма был написан собственноручно студентом или прошел глубокую адаптацию под программу студента.
2. Поощряется использование модифицированных алгоритмов с курсов. «Основы программирования на С#. Часть 2» или «Основы программирования на С#. Часть 1». Модифицированный алгоритм с курса – алгоритм, который студент написал собственноручно в одном из практических заданий курса «Основы программирования на С#. Часть 2» или «Основы программирования на С#. Часть 1», но при этом изменил не только тип входных или выходных параметров, а также внес изменения в код алгоритма, повлекшие изменения в порядке или схеме работы алгоритма. Внесение изменений, не приведших к изменению хода работы алгоритма - нельзя считать причиной классифицировать алгоритм как «Модифицированный».
3. Использование не модифицированных алгоритмов с курсов «Основы программирования на С#. Часть 2» или «Основы программирования на С#. Часть 1» разрешается. Не модифицированный алгоритм с курса – алгоритм, который студент написал собственноручно в одном из практических заданий курса «Основы программирования на С#. Часть 2» или «Основы программирования на С#. Часть 1». В случае, если было доказано, что студент не писал представленный в программе алгоритм, он перестает считаться не модифицированным алгоритмом.
4. Отсутствие специальных алгоритмов в коде игры говорит о её тривиальности и свидетельствует о низком уровне сложности продукта и оригинальности игровых механик. Специальным считается алгоритм – который был разработан лично студентом под созданные им классы, решающий задачу в рамках его приложения. Если этот алгоритм уже был ранее написан кем-либо для решения своей задачи он считается специальным только если студент лично адаптировал его под свою задачу с изменением не только типов входных и выходных параметров, но и кода алгоритма.


## Техническая проработанность проекта
1. **Законченность**. В игре реализована возможность запустить игру и выйти из нее. При запуске игры пользователь попадает в главное меню, из которого может запустить игру. В случае реализации звуковых эффектов – в игре реализована возможность настройки их громкости или их отключения. В игре не было выявлено ошибок, приводящих к закрытию приложения или вывода из строя устройства пользователя. Игру можно пройти, критерии прохождения четко прослеживаются в процессе геймплея. Можно выиграть и проиграть. В случае, если игра не дает ответа на то, победил ли игрок, она должна предоставить возможность игроку дойти до «Финала». Если игра бесконечная, то «Финалом» считается поражение игрока.
2. Корректность и эффективность использование компонентов игрового движка. Компоненты игрового движка используются по назначению с учетом официальной документации компании-разработчика движка.
3. Работоспособность. Игра запускается на всех типах устройств, заявленных студентом. Работа игры не вызывает ошибок системы, выводящих из строя или наносящих вред устройству пользователя.
4. Производительность. Игра потребляет менее 1 ГБ оперативной памяти и работает исправно, не вызывая критической загрузки компонентов систем, имеющих процессоры выпуска не ранее 2010 года с количеством ядер от 2-х, с оперативной памятью не менее 4 ГБ. Объем дискового пространства, занимаемого игрой, не должен превышать 1 ГБ.
5. Целостность (внешняя и внутренняя). Четко прослеживается игровой цикл и цели игрока. Геймплей игры позволяет в течение 5 минут ознакомиться со всеми ключевыми механиками игры. Элементы интерфейса по визуальному стилю соответствуют друг другу и элементам наполнения игры – спрайтам юнитов, игрового поля.


## Играбельность
1. Игра должна быть в значительной мере уникальна. Вариации на тему Диггера запрещены. Нельзя реализовать существующую игру с классическими правилами (шашки, покер, pac-man). 
2. Геймплей. Насколько интересно играть в игру. Также признак интересной игры: в нее хочется играть хотя бы 5 минут.
3. Удобство и понятность. Оценивается проработка пользовательских сценариев. У игрока не должно возникать вопросов вида «а что теперь делать?». Игра должна быть понятной и не ставить игрока в тупик. Очень простые игры, где естественно «все очевидно» не могут получить много баллов.
4. Содержание. Оценивается проработка сюжета, персонажей, в целом проработка мира и создание атмосферы игры, оригинальность мира игры.
5. Оформление. Оценивается графика, визуальный стиль. Можно заимствовать из открытых источников. Главное, чтобы все это гармонично сочеталось. Хорошее оформление должно поддерживать атмосферу, быть уместным.

Балл за играбельность — это не сумма баллов за все компоненты. Если два компонента сделаны хорошо, то это уже хорошая игра. И в силу особенностей выбранного жанра какие-то компоненты могут быть плохо применены к игре.
